<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Magic Tiles | Hazel</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Magic Tiles" />
<meta name="author" content="Hazel Chen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Watch it in GitHub Keywords: UART, Python, FPGA, Music Game. Introduction About the game This project is a two-player rhythm game. Tiles with a number fall from the top of the screen on laptop along a rail, and players use keypad to input the number of the falling tiles, while the switch allows song selection. Two sets of 7-segment displays show individual player scores. When either player reaches 60 points, the Python interface is automatically closed, and LED color indicates the winner. The system uses bidirectional UART communication, either via the FPGA board’s built-in serial port or through AD2 pins. Implementation How we realize interaction between FPGA and Python 1. Build UART module First, I try to learn the principle of UART, especially the types of the signal and how the states should be. It had been a long time before the module was completed, though, just as you can see in our work log. We searched for much info online. Figure 2-1. UART transmits one bit at once, and we must wrap the desired signal between start bit (0) and stop bit (1). In Figure 2-3, they show the transmitter of UART (module UART_TX_CTRL). (1) Baud rate setting We make our FPGA transfer 9600 bits in a second. In Row 19 and 23, we design a counter to return 0 every 10416 clocks. (2) FSM (txState) ⚫ RDY (Idle state) Waits for SEND to go high. ⚫ LOAD_BIT Loads txData as {1’b1, DATA, 1’b0. } That is, stop bit (1), 8 data bits, start bit (0). ⚫ SEND_BIT Uses bitTmr to maintain the baud rate. Increments bitIndex until all 10 bits are sent (start + 8 data + stop). Figure 2-2. UART_TX_CTRL In terms of the receiver (module UART_RX_CTRL), FSM of receiver ⚫ IDLE Wait for the start bit. If start bit detected, reset bit_timer and bit_index, and go to START. ⚫ START Confirm the start bit is valid, if not, go back IDLE. BIT_MID = ~half of BIT_TMR_MAX (Row 37), ensuring sampling at the center of the bit. ⚫ RECEIVE Store a bit in shift_reg . After receiving 8 bits, move to STOP. ⚫ STOP Wait for stop bit, transfer the 8-bit data to DATA, and return to IDLE. 2. Write Python Code (1) Connect with FPGA uart.py is to interact with FPGA. We first check device manager to know the port name “COM3” and set the baud rate as 9600 (the same as we design in Verilog). And as Row 11 ~18 in Figure 2-5, we open serial port via giving the info of FPGA UART. (2) Connect with AD2 Thankfully, WaveForms SDK has provided sample code for downloader to manage AD2 with Python/C++ (Ref[4]). Yet, we must modify it. The file note_rx.py is to used interact with AD2. The main function of AD2 UART is to receive notes when the game starts. In Figure 2-6, Python send ‘R’ to FPGA to request for left-hand notes and ‘r’ to request right-hand notes. As Row 60-61, we must decode the 8-bit received data with ASCII to get the alphabet. The notes_raw (Row 68) is like ‘A2E2C3…’ with ABC being the number corresponding to keypad and 123 being the duration. Another function of AD2 is to detect the rail location. There are 4 rails for a hand, and we randomly determine it with module lfsr. The random rail code is obtained by detecting the high/low level of the DIO[14] and DIO[15] when the new tile is spawned. (3) Rendering We use pygame to do the rendering. In Figure 2-7, the left 4 rails are for left-hand player, and the right 4 rails are for right-hand player. 3. Signal Flow in the Game Loop This table describes how signals flow between the PC (Personal Computer) and FPGA during different phases of the rhythm game. Time Direction Function Game start PC → FPGA Request for notation After request FPGA → PC Transfer info about notes During Game FPGA → PC Send user input (FPGA buttons or keyboard) During Game PC → FPGA Feedback on the correctness of the notes Game end FPGA → PC Close the game" />
<meta property="og:description" content="Watch it in GitHub Keywords: UART, Python, FPGA, Music Game. Introduction About the game This project is a two-player rhythm game. Tiles with a number fall from the top of the screen on laptop along a rail, and players use keypad to input the number of the falling tiles, while the switch allows song selection. Two sets of 7-segment displays show individual player scores. When either player reaches 60 points, the Python interface is automatically closed, and LED color indicates the winner. The system uses bidirectional UART communication, either via the FPGA board’s built-in serial port or through AD2 pins. Implementation How we realize interaction between FPGA and Python 1. Build UART module First, I try to learn the principle of UART, especially the types of the signal and how the states should be. It had been a long time before the module was completed, though, just as you can see in our work log. We searched for much info online. Figure 2-1. UART transmits one bit at once, and we must wrap the desired signal between start bit (0) and stop bit (1). In Figure 2-3, they show the transmitter of UART (module UART_TX_CTRL). (1) Baud rate setting We make our FPGA transfer 9600 bits in a second. In Row 19 and 23, we design a counter to return 0 every 10416 clocks. (2) FSM (txState) ⚫ RDY (Idle state) Waits for SEND to go high. ⚫ LOAD_BIT Loads txData as {1’b1, DATA, 1’b0. } That is, stop bit (1), 8 data bits, start bit (0). ⚫ SEND_BIT Uses bitTmr to maintain the baud rate. Increments bitIndex until all 10 bits are sent (start + 8 data + stop). Figure 2-2. UART_TX_CTRL In terms of the receiver (module UART_RX_CTRL), FSM of receiver ⚫ IDLE Wait for the start bit. If start bit detected, reset bit_timer and bit_index, and go to START. ⚫ START Confirm the start bit is valid, if not, go back IDLE. BIT_MID = ~half of BIT_TMR_MAX (Row 37), ensuring sampling at the center of the bit. ⚫ RECEIVE Store a bit in shift_reg . After receiving 8 bits, move to STOP. ⚫ STOP Wait for stop bit, transfer the 8-bit data to DATA, and return to IDLE. 2. Write Python Code (1) Connect with FPGA uart.py is to interact with FPGA. We first check device manager to know the port name “COM3” and set the baud rate as 9600 (the same as we design in Verilog). And as Row 11 ~18 in Figure 2-5, we open serial port via giving the info of FPGA UART. (2) Connect with AD2 Thankfully, WaveForms SDK has provided sample code for downloader to manage AD2 with Python/C++ (Ref[4]). Yet, we must modify it. The file note_rx.py is to used interact with AD2. The main function of AD2 UART is to receive notes when the game starts. In Figure 2-6, Python send ‘R’ to FPGA to request for left-hand notes and ‘r’ to request right-hand notes. As Row 60-61, we must decode the 8-bit received data with ASCII to get the alphabet. The notes_raw (Row 68) is like ‘A2E2C3…’ with ABC being the number corresponding to keypad and 123 being the duration. Another function of AD2 is to detect the rail location. There are 4 rails for a hand, and we randomly determine it with module lfsr. The random rail code is obtained by detecting the high/low level of the DIO[14] and DIO[15] when the new tile is spawned. (3) Rendering We use pygame to do the rendering. In Figure 2-7, the left 4 rails are for left-hand player, and the right 4 rails are for right-hand player. 3. Signal Flow in the Game Loop This table describes how signals flow between the PC (Personal Computer) and FPGA during different phases of the rhythm game. Time Direction Function Game start PC → FPGA Request for notation After request FPGA → PC Transfer info about notes During Game FPGA → PC Send user input (FPGA buttons or keyboard) During Game PC → FPGA Feedback on the correctness of the notes Game end FPGA → PC Close the game" />
<link rel="canonical" href="http://localhost:4000/Hazel-the-Cat/jekyll/update/2025/06/13/Magic-Tiles.html" />
<meta property="og:url" content="http://localhost:4000/Hazel-the-Cat/jekyll/update/2025/06/13/Magic-Tiles.html" />
<meta property="og:site_name" content="Hazel" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-06-13T18:42:19+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Magic Tiles" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Hazel Chen"},"dateModified":"2025-06-13T18:42:19+08:00","datePublished":"2025-06-13T18:42:19+08:00","description":"Watch it in GitHub Keywords: UART, Python, FPGA, Music Game. Introduction About the game This project is a two-player rhythm game. Tiles with a number fall from the top of the screen on laptop along a rail, and players use keypad to input the number of the falling tiles, while the switch allows song selection. Two sets of 7-segment displays show individual player scores. When either player reaches 60 points, the Python interface is automatically closed, and LED color indicates the winner. The system uses bidirectional UART communication, either via the FPGA board’s built-in serial port or through AD2 pins. Implementation How we realize interaction between FPGA and Python 1. Build UART module First, I try to learn the principle of UART, especially the types of the signal and how the states should be. It had been a long time before the module was completed, though, just as you can see in our work log. We searched for much info online. Figure 2-1. UART transmits one bit at once, and we must wrap the desired signal between start bit (0) and stop bit (1). In Figure 2-3, they show the transmitter of UART (module UART_TX_CTRL). (1) Baud rate setting We make our FPGA transfer 9600 bits in a second. In Row 19 and 23, we design a counter to return 0 every 10416 clocks. (2) FSM (txState) ⚫ RDY (Idle state) Waits for SEND to go high. ⚫ LOAD_BIT Loads txData as {1’b1, DATA, 1’b0. } That is, stop bit (1), 8 data bits, start bit (0). ⚫ SEND_BIT Uses bitTmr to maintain the baud rate. Increments bitIndex until all 10 bits are sent (start + 8 data + stop). Figure 2-2. UART_TX_CTRL In terms of the receiver (module UART_RX_CTRL), FSM of receiver ⚫ IDLE Wait for the start bit. If start bit detected, reset bit_timer and bit_index, and go to START. ⚫ START Confirm the start bit is valid, if not, go back IDLE. BIT_MID = ~half of BIT_TMR_MAX (Row 37), ensuring sampling at the center of the bit. ⚫ RECEIVE Store a bit in shift_reg . After receiving 8 bits, move to STOP. ⚫ STOP Wait for stop bit, transfer the 8-bit data to DATA, and return to IDLE. 2. Write Python Code (1) Connect with FPGA uart.py is to interact with FPGA. We first check device manager to know the port name “COM3” and set the baud rate as 9600 (the same as we design in Verilog). And as Row 11 ~18 in Figure 2-5, we open serial port via giving the info of FPGA UART. (2) Connect with AD2 Thankfully, WaveForms SDK has provided sample code for downloader to manage AD2 with Python/C++ (Ref[4]). Yet, we must modify it. The file note_rx.py is to used interact with AD2. The main function of AD2 UART is to receive notes when the game starts. In Figure 2-6, Python send ‘R’ to FPGA to request for left-hand notes and ‘r’ to request right-hand notes. As Row 60-61, we must decode the 8-bit received data with ASCII to get the alphabet. The notes_raw (Row 68) is like ‘A2E2C3…’ with ABC being the number corresponding to keypad and 123 being the duration. Another function of AD2 is to detect the rail location. There are 4 rails for a hand, and we randomly determine it with module lfsr. The random rail code is obtained by detecting the high/low level of the DIO[14] and DIO[15] when the new tile is spawned. (3) Rendering We use pygame to do the rendering. In Figure 2-7, the left 4 rails are for left-hand player, and the right 4 rails are for right-hand player. 3. Signal Flow in the Game Loop This table describes how signals flow between the PC (Personal Computer) and FPGA during different phases of the rhythm game. Time Direction Function Game start PC → FPGA Request for notation After request FPGA → PC Transfer info about notes During Game FPGA → PC Send user input (FPGA buttons or keyboard) During Game PC → FPGA Feedback on the correctness of the notes Game end FPGA → PC Close the game","headline":"Magic Tiles","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Hazel-the-Cat/jekyll/update/2025/06/13/Magic-Tiles.html"},"url":"http://localhost:4000/Hazel-the-Cat/jekyll/update/2025/06/13/Magic-Tiles.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/Hazel-the-Cat/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/Hazel-the-Cat/feed.xml" title="Hazel" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/Hazel-the-Cat/">Hazel</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Hazel-the-Cat/campus.html">校園</a><a class="page-link" href="/Hazel-the-Cat/courses.html">修課</a><a class="page-link" href="/Hazel-the-Cat/project.html">Projects</a><a class="page-link" href="/Hazel-the-Cat/ramble.html">隨筆</a><a class="page-link" href="/Hazel-the-Cat/vlog.html">Vlog</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Magic Tiles</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-06-13T18:42:19+08:00" itemprop="datePublished">Jun 13, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul>
  <li><a href="https://github.com/Hazel-1212/Magic_Tiles.git">Watch it in GitHub</a></li>
  <li>Keywords: <em>UART, Python, FPGA, Music Game</em>.</li>
</ul>

<h2 id="introduction"><strong>Introduction</strong></h2>
<ol>
  <li><strong>About the game</strong></li>
</ol>

<p>This project is a two-player rhythm game. Tiles with
a number fall from the top of the screen on laptop along a
rail, and players use keypad to input the number of the
falling tiles, while the switch allows song selection.</p>

<p>Two sets of 7-segment displays show individual
player scores. When either player reaches 60 points, the
Python interface is automatically closed, and LED color
indicates the winner.</p>

<p>The system uses bidirectional UART
communication, either via the FPGA board’s built-in
serial port or through AD2 pins.</p>

<h2 id="implementation"><strong>Implementation</strong></h2>
<h3 id="how-we-realize-interaction-between-fpga-and-python"><strong>How we realize interaction between FPGA and Python</strong></h3>

<h4 id="1-build-uart-module"><strong>1. Build UART module</strong></h4>
<p>First, I try to learn the principle of UART, especially the types of the signal and how the
states should be. It had been a long time before the module was completed, though, just as
you can see in our work log. We searched for much info online.</p>

<p>Figure 2-1. UART transmits one bit at once,</p>

<p>and we must wrap the desired signal between start bit (0) and stop bit (1).</p>

<p>In Figure 2-3, they show the transmitter of UART (module UART_TX_CTRL).</p>

<p><strong>(1) Baud rate setting</strong></p>

<p>We make our FPGA transfer 9600 bits in a second. In Row 19 and 23, we design a
counter to return 0 every 10416 clocks.</p>

<p><strong>(2) FSM (txState)</strong></p>

<p>⚫ RDY (Idle state)</p>

<p>Waits for SEND to go high.</p>

<p>⚫ LOAD_BIT</p>

<p>Loads txData as {1’b1, DATA, 1’b0. } That is,
stop bit (1), 8 data bits, start bit (0).</p>

<p>⚫ SEND_BIT</p>

<p>Uses bitTmr to maintain the baud rate.
Increments bitIndex until all 10 bits are sent
(start + 8 data + stop).</p>

<p>Figure 2-2. UART_TX_CTRL</p>

<p>In terms of the receiver (module UART_RX_CTRL),</p>

<p><strong>FSM of receiver</strong></p>

<p>⚫ IDLE</p>

<p>Wait for the start bit. If start bit detected,
reset bit_timer and bit_index, and go to START.</p>

<p>⚫ START</p>

<p>Confirm the start bit is valid, if not, go back IDLE.</p>

<p>BIT_MID = ~half of BIT_TMR_MAX (Row 37), ensuring sampling at the center of the bit.</p>

<p>⚫ RECEIVE</p>

<p>Store a bit in shift_reg . After receiving 8 bits, move to STOP.</p>

<p>⚫ STOP</p>

<p>Wait for stop bit, transfer the 8-bit data to DATA, and return to IDLE.</p>

<h4 id="2-write-python-code"><strong>2. Write Python Code</strong></h4>

<p><strong>(1) Connect with FPGA</strong></p>

<p>uart.py is to interact with FPGA.
We first check device manager to know the
port name “COM3” and set the baud rate as
9600 (the same as we design in Verilog). And
as Row 11 ~18 in Figure 2-5, we open serial
port via giving the info of FPGA UART.</p>

<p><strong>(2) Connect with AD2</strong></p>

<p>Thankfully, WaveForms SDK has provided
sample code for downloader to manage AD2
with Python/C++ (Ref[4]).
Yet, we must modify it. The file note_rx.py
is to used interact with AD2.</p>

<p>The main function of AD2 UART is to
receive notes when the game starts. In
Figure 2-6, Python send ‘R’ to FPGA to
request for left-hand notes and ‘r’ to request
right-hand notes. As Row 60-61, we must
decode the 8-bit received data with ASCII
to get the alphabet. The notes_raw (Row 68) is like ‘A2E2C3…’ with ABC being the
number corresponding to keypad and 123
being the duration.</p>

<p>Another function of AD2 is to detect
the rail location. There are 4 rails for a
hand, and we randomly determine it with
module lfsr. The random rail code is
obtained by detecting the high/low level of
the DIO[14] and DIO[15] when the new tile
is spawned.</p>

<p><strong>(3) Rendering</strong></p>

<p>We use pygame to do the rendering. In Figure
2-7, the left 4 rails are for left-hand player, and the
right 4 rails are for right-hand player.</p>

<h4 id="3-signal-flow-in-the-game-loop"><strong>3. Signal Flow in the Game Loop</strong></h4>

<p>This table describes how signals flow between the PC (Personal Computer) and FPGA during different phases of the rhythm game.</p>

<table>
  <thead>
    <tr>
      <th>Time</th>
      <th>Direction</th>
      <th>Function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Game start</td>
      <td>PC → FPGA</td>
      <td>Request for notation</td>
    </tr>
    <tr>
      <td>After request</td>
      <td>FPGA → PC</td>
      <td>Transfer info about notes</td>
    </tr>
    <tr>
      <td>During Game</td>
      <td>FPGA → PC</td>
      <td>Send user input (FPGA buttons or keyboard)</td>
    </tr>
    <tr>
      <td>During Game</td>
      <td>PC → FPGA</td>
      <td>Feedback on the correctness of the notes</td>
    </tr>
    <tr>
      <td>Game end</td>
      <td>FPGA → PC</td>
      <td>Close the game</td>
    </tr>
  </tbody>
</table>

  </div><a class="u-url" href="/Hazel-the-Cat/jekyll/update/2025/06/13/Magic-Tiles.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/Hazel-the-Cat/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Hazel</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Hazel Chen</li><li><a class="u-email" href="mailto:achievegoal9@gmail.com">achievegoal9@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hazel Chen, a student in NYCU Electrical Engineering, is documenting her journey in engineering, actuarial science, and tech projects.  交大電機修課/期末專題/交大工讀生。</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
